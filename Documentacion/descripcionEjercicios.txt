Ejercicio 01:
Servlet simple que genera y escupe código html mostrando el mensaje de "hola mundo".
Para ver el resultado debemos ejecutar el servlet de forma directa en Tomcat ya que el proyecto web no contiene el fichero web.xml.

Ejercicio 02:
Servlet simple que genera y escupe código html. El contenido html es una tabla que contiene las multiplicaciones del 1 al 10.
Agregamos indentación en el código html que escupe, esta acción se realiza para cuando hacemos Ctrl + U en el navegador, este nos muestre un código legible y ordenado.
Para ver el resultado debemos ejecutar el servlet de forma directa en Tomcat ya que el proyecto web no contiene el fichero web.xml.

Ejercicio 03:
Enviar dato a travez de formulario de tipo POST.
Servlet que muestra un mensaje de saludo personalizado en función del nombre que escriba el usuario en el formulario, este está definido en el fichero index.html.
A partir de este ejercicio es cuando empezamos a usar los fichero HTML, la codificación de estos ficheros debe ser UTF-8, de tal manera que:
<meta charset="UTF-8">
Enviar dato a travez de formulario de tipo POST. Con el tipo POST estamos ocultando la información que enviamos.
A partir de este ejercicio, todos los proyectos contendrán el ficheroweb.xml, es decir, que podemos ejecutar desde el propio proyecto y empezamosa usar páginas HTML5, estilos CSS y validaciones JS, a medida que avancemosen los ejercicios, el CSS y JS irá creciendo (Por el momento solo afectan a los ficheros html).
Definimos en fichero web.xml la página de inicio del proyecto, en nuestro caso index.html
Añadimos validación JS sobre el campo texto y la manera de invocar la validación es a travez del id que damos al formulario definido en index.html.

Ejercicio 04:
Enviar dato a travez de formulario de tipo POST y usamos atributo ONSUBMIT del formulario definido en index.html.
Servlet que muestra las multiplicaciones del 1 al 10 de un número introducido por el usuario en el formulario definido en el fichero index.html. 
Agregamos botón para volver, es código JS que nos envía a la página de inicio. Se añade validación de dato numérico en formulario mediante JS, al igual que en el ejercicio 04 los ficheros CSS y JS solo afectan a los ficheros html.

Ejercicio 05:
Enviar dato a travéz de formulario de tipo GET y usamos atributo ONSUBMIT.
Servlet que muestra información capturada de formulario implementado enfichero index.html, el formulario contiene validaciones propias, es decir, en la propia etiqueta INPUT.
Los TYPE de INPUT que usamos son: "text", "number", "date", "checkbox" y "radio". Para el ComboBox hemos usado el tag "select".
Enviar dato a travéz de formulario de tipo GET y usamos atributo ONSUBMIT. El modo GET muestra los valores que se están enviando en la URL, es decir, son visibles.
Usamos función JS que contiene validaciones sobre los campos del formulario.
Se añade filtro en el campo numérico, en concreto, de mínimo y máximo de edad, definido en la propia etiqueta INPUT.
Todas las páginas que no tienen CSS ni JS son las que genera y escupe el propio Servlet.

Ejercicio 06:
Invocación de Servlet sin usar formulario.
Invocación de Servlet que muestra un mensaje de bienvenida con un color de fondo, dicho color dependerá de la opción que el usuario eliga desde las opciones de index.html y que lo aplica directamente en el código html que genera y escupe, es decir, no usa ningún fichero CSS.
En este caso se hace la llamada directa del servlet desde un link o botón, tenemos que tener en cuenta que el dato que estamos enviando desde index.html al servlet, lo adjuntamos en la llamada al servlet, por tanto, es como si usásemos un formulario de tipo GET, ya que el dato viaja en la URL tal que:
MiServlet?nombre=valor&nombre=valor&nombre=valor
A partir de este ejercicio, empezamos a añadir codificación a las páginas generadas en los Servlet, es decir, agregamos la línea: out.println("<meta charset='UTF-8'>");
En este ejercicio solo usamos CSS. Fijamos un tamaño de 100px para el botón de tamaño medio, así evitamos que su tamaño esté en función de su texto.

Ejercicio 07:
Servlets SIN dar RESPUESTA a CLIENTE.
A partir de este ejercicio, las descripciones definidas en JavaDoc serán exclusivas de cada clase. La información completa del ejercicio estará definida en este fichero.
Traspaso de dato request entre servlets: En el fichero index.html hay un formulario que recoge un dato llamado "nombre" y que pertenece al request, pues bien, este dato se envía al primer servelt (ServletUno) y este no hace nada con el dato "nombre", mas bien agrega un nuevo dato request llamado "dato" y hace la invocación del servlet final (ServletDos).
La gracia de este ejercicio es que cuando el primer servlet llama al segundo, este es llamado SIN dar RESPUESTA a CLIENTE. Con ello conseguimos mantener el dato "nombre" y no perderlo, por ello cuando llegamos al segundo servlet, este tiene dos datos: "nombre" y "dato".
Para invocar a un Servlet sin dar respuesta al cliente, tenemos que usar: "request.getRequestDispatcher("Servlet").forward(request, response);"
Esta acción de recoger y generar nuevos datos lo veremos en más detalle en el ejercicio 10, ya que se trata de atributos de petición, los cuales existen mientras no se de respuesta al cliente.

Ejercicio 08:
Login simple SIN dar RESPUESTA a CLIENTE.
Consta de tres Servlets, donde el principal invoca a uno u otro en función de si la contraseña está correcta o no. El servlet destino puede leer datos que ha recogido el servlet principal desde el formularo porque el servlet principal no da respuesta al cliente, simplemente invoca a otro servlet por lo cual, no se pierde la información.
Para ello, al igual que el ejercicio 07, usa el método: FORWARD.
Actualizamos variable de control en JS, deja de ser un número entero para ser una bandera de tipo boolean y añadimos valicación de campo de TYPE "password". En JS no hay tipado, pero al darle el valor a la variable, esta pasa a ser de un tipo u otro.

Ejercicio 9:
Login simple con RESPUESTA a CLIENTE.
Para dar respuesta al cliente de forma directa, usaremos el objeto RESPONSE, el cual contiene el método "SEND_REDIRECT", es decir: "response.sendRedirect("Bienvenido?user=" + user);".
En las llamadas a otros servlets, si no se adjuntan los datos, estos nunca llegarán, ya que al enviar la respuesta a cliente, los datos existentes en el objeto request desaparecen.
Usa JS para las validaciones de formulario.

>> La diferencia en dar o no respuesta al cliente reside en:
>> 1º Si no damos respuesta a cliente, no perdemos los datos de la petición y es más rápida la navegación. No se actualiza página.
>> 2º Si la damos, perdemos los datos de la petición y es más lenta la navegación. Tiene actualización automática de página.

Ejercicio 10:
Login simple - Atributo de Petición.
Almacena los datos obtenidos del request en un Bean y este lo trata como un único atributo de peticion, el otro servlet lee el atributo de petición (Objeto).
Toda la información que se guarde en el Bean request existirá mientras no se envíe respuesta al cliente, en cuanto demos respuesta al cliente, toda la información desaparecerá.
Por tanto, cuando invocamos a otro Servlet, lo tendremos que hacer con FORWARD.

Ejercicio 11:
Contador - Atributo de Sesión.
El atributo de sesión existe mientras la sesión esté abierta (Podemos definir el tiempo que dura una sesión), por tanto, el enviar respuesta al cliente no le afecta.
En este caso se envía la respuesta al cliente "SEND_REDIRECT" para que se haga efectivo el contéo de pulsaciones del botón.
Para DEFINIR el "TIEMPO de SESIÓN", agregamos el time-out en nuestro fichero de apliación "web.xml".
Se definen 3 clases CSS de botones: 1:.boton, su tamaño se adapta al texto que cotiene, 2: .botonMedio, tiene un tamaño fijo de 100px y 3: .botonLargo, tiene un tamaño fijo de 140px.
No contiene fichero JS ya que no existe formulario a validar.

Ejercicio 12:
Login simple Atr. de petición y Atr. de sesión.
Si el login es correcto se genera un atributo de sesión que contiene un bean y envía respuesta al cliente, de no serlo, no envía respuesta a cliente y envía los datos al servlet de error como atributo de petición. Hay que tener en cuenta que para leer los atributos de sesión, tenemos que obtener la sesión actual (HttpSession session = request.getSession(false);).
Se añade la opción de CERRAR SESION para el servlet final.
Usa JS para las validaciones de formulario.

---------------------------------------------------------------------
-- Usamos ficheros JSP con HTML5
---------------------------------------------------------------------

Ejercicio 13:
Copia del ejecicio dos. Multiplicaciones en tabla con estilo CSS.
A partir de este ejercicio ya no generamos HTML desde los Servlet.
Es el primer contacto con ficheros JSP + HTML5, por ello la primera línea de la JSP es: <%@ page language="java" pageEncoding="UTF-8"%>, importante el tema de codificación, seguimos manteniendo UTF-8.
La funcionalidad es la misma que la del ejercicio 02, pero no usamos servlets ya que implementamos la lógica en el fichero JSP con código Java embebido.
Continuamos con proyectos web que usan el fichero "web.xml" para definir la página de inicio, por tanto, podemos seguir ejecutando desde aplicación.
Se añade estilo CSS para tablas y se fija el ancho de la clase ".main" a un 80%.

Ejercicio 14:
Copia del ejercicio doce. <%=request.getParameter("tema")%> y <%=session.getAttribute("usuario")%>
La primera diferencia que observamos, es que ya no usamos Bean para almacenarlo como atributo de petición. Esto lo hacemos para no complicar mucho la definición de las JSP destino.
Los servlets encargados de montrar las páginas de respuestas son sustituidos por páginas JSP (TemaElegido.java > bienvenido.jsp || Error.java > error.jsp), donde se usa HTML5, por tanto, podemos aplicar estilos CSS y validaciones JS.
Desde JSP se leen los atributos de sesión (session) y de petición (request) de forma directa.

---------------------------------------------------------------------
-- Validación de formulario por THIS
---------------------------------------------------------------------

Ejercicio 15:
Copia del ejecicio cuatro. Funcionalidad <%@ include file="fichero.jsp"%> de JSP
Este ejercicio muestra como agregar código HTML5 a una página JSP. La plantilla que hace referencia al pie de la página es un fichero JSP para poder definir el encoding UTF-8, ya que si lo hacíamos en un fichero HTML5, teníamos que definir una estructura completa de HTML5.
La diferencia es que se sustituyen los servlet que generan páginas HTML por ficheros JSP con HTML5.
Se añade validación JS sobre el campo del fichero "index.html", el cual está definido en un formulario. Pasamos de forma directa el objeto formulario como parámetro (THIS) a la función JS, lo cual nos ahorra el atributo id. El TYPE del campo es "text" para que pueda saltar el error si no introducimos un número entero.
Agregamos un array de resultados como atributo de petición (request) y re-direccionamos a página JSP que lea y muestre dichos resultados.

Ejercicio 16:
Uso de <%@ page import="obj.java"%> y <jsp:forward page="fich.html"/> en JSP.
El carrito es una lista de productos, esta lista está guardada a nivel de sesión. El usuario puede AGREGAR o ELIMINAR productos, estas acciones se reflejan en el resultado final, es decir, que se tiene el carrito actualizado (Daremos respuesta al cliente para que la página se actualice con el cambio realizado).
En este ejercicio se ve como un fichero JSP puede leer una Lista de productos (List) y mostrar su información, para ello importa el objeto bean Producto y el objeto List que contiene esos Productos al inicio del fichero JSP.
Por otro lado tenemos el como JSP hace una re dirección, es decir, que invoca a un recurso sin enviar respuesta a cliente (<jsp:forward page="recurso"/>).
Para eliminar un producto, nos basamos en el índice, el cual se genera cuando estamos pintando la tabla de productos del carrito.
Se añade validaciones JS para los campos del formulario encargado de agregar un nuevo producto en el carrito.
Los formularios y tablas CSS pasan a tener el ancho que ocupen su contenido, es decir, "display: inline-block". Tambien agregamos que en el TYPE "number", cuando el usuario use las flechitas, el número aumente un 0,01 por cada pulsación (step="0.01").
Definición de la codificación en los servlet a UTF-8, ya que cuando insertamos caracteres especiales en los formularios, estos no se tratan de forma correcta en los servlet, lo que implica que los mostrará de forma incorrecta en la página web.

Ejercicio 17:
Contador JSP - Atributo de Aplicación.
Uso de método init() de servlet para realizar acciones antes de formar el servlet y publicar en el servidor. Gestionamos variables a nivel de sesión y de aplicación.
Al usar un atributo de aplicación, el cual es compartido por todas las sesiones de la aplicación, debemos usar el método synchronized de Java para que no se pierda información y no se bloqueen las sesiones que intentan acceder a la vez a los atributos de aplicación.
Obtenemos el contexto de la aplicación ya que en dicho contexto es donde están los atributos de aplicación, la forma de acceso cambia, pero la idea es igual que cuando obtenemos la sesión.
Al igual que en el ejercico once, definimos el TIMEOUT de la sesión, en este caso lo mantenemos en 1 minuto.
Desde fichero JSP accedemos al nivel de sesión y aplicación para leer la información del los contadores.

Ejercicio 18:
Votaciones a nivel de Aplicación.
Uso del método init() para inicializar valores, en este caso, variables a nivel de aplicación, seguimos usando método "synchronized".
Lectura de datos de formulario, nivel petición y lectura de datos a nivel de aplicación.
El tiempo de sesión se establece a 1 minuto, es decir, seguimos manteniendo fichero web.xml del ejercicio 11.
Aplicamos nueva validación JS genérica para cualquier tipo de radio button.
Definimos CSS para poder tener dos botones en formulario y el formulario centrado, basta con usar "display: inline-block".
Desde fichero JSP accedemos al nivel de aplicación, agregamos una nueva "importación de objeto" para mostrar valores numéricos con dos decimales (BigDecimal).

Ejercicion 19:
Uso de <%! Método Java %> en JSP. Crear, escribir (Java) y leer una cookie (JSP).
Aplicación del ejercicio diecisiete, se le añade la funcionalidad de Cookie. La información que almacena una Cookie es texto y el el contenido es una fecha.
Se aplica formato de fecha-hora de objeto LocalDateTime de Java, ello implica crear la Cookie usando objeto "URLEncoder" para codificar en Java y "URLDecoder" para descodificar y leer en JSP.
No contiene carpeta JS.

Ejercicio 20:
Página de inicio JSP que lee Cookie.
Uso de funcionalidad de Cookie para recordar el nombre de usuario cuando se realiza el formulario de Login.
Se agrega carpeta JS y se añade validacion de campos vacíos para el formulario de Login.
Es una copia del ejercicio catorce, pero el fichero "index.html" pasa a ser un JSP para poder leer la Cookie. Implica modificar el fichero web.xml para que la página de inicio no sea un HTML si no un JSP.
Codificamos la página JSP en UTF-8.
Si se marca el check, el valor que se envía es el que está adjunto al atributo de "value" del input. No se guarda el estado del check, es decir, si lo marcamos, en cuanto nos desconectemos, el check vuelve a su estado inicial (Sin marcar).

Ejercicio 21:
Uso de Listener @ WebListener.
Es una copia del ejercicio dieciocho, la modificación que hacemos es quitar el método init() y sustituirlo por una clase de tipo "Listener" que realiza la misma funcionalidad, es decir, inicializar valores de las variables antes de crear el Servlet en sí.
Existen 3 tipos de Listener importantes (https://www.arquitecturajava.com/servletcontextlistener/), el nuestro se ejecutará en cuanto arranque la aplicación, en este caso, inicializa valores al iniciar la apliación.
Hemos usado una anotación, sin embargo se puede definir su funcionalidad y orden en el fichero web.xml, pero por comodidad lo hacemos por anotación.
